^'// Autogenerated by empy! Install with "pip install empy"'
^'// Edit osc_empy.v and then run'
^'// python -m em -p ^ osc_empy.v > osc.v'

/* 
functional model for an oscillator

     0      0.2     0.4     0.6     0.8      1
     |       |       |       |       |       |
A   _.- - - - - - - - - -._ _ _ _ _ _ _ _ _ _.-
     |       |       |       |       |       |
B   - - -._ _ _ _ _ _ _ _ _ _.- - - - - - - - -
     |       |       |       |       |       |
C   _ _ _ _ _.- - - - - - - - - -._ _ _ _ _ _ _
     |       |       |       |       |       |
D   - - - - - - -._ _ _ _ _ _ _ _ _ _.- - - - -
     |       |       |       |       |       |
E   _ _ _ _ _ _ _ _ _.- - - - - - - - - -._ _ _
     |       |       |       |       |       |

*/

^{output_names = ['out_a', 'out_b', 'out_c', 'out_d', 'out_e']}
^{N = len(output_names)}

`timescale 1ps/1ps

module osc (
    input [1:0] ctrl,
^[for i, output_name in enumerate(output_names)]^
    output reg ^output_name^(',' if i != N-1 else '')
^[end for]^
);

// timeunit / 2 is a good choice for EPSILON
localparam EPSILON = 1e-12/2;

// duration of one period and delay between edges
real period_seconds;
real period;
real edge_delay;

integer event_id = 1;
real next_edge_time;

event recalculate;
event schedule_recalculate;


initial begin
    // Set outputs to time 0+epsilon
^[for i, output_name in enumerate(output_names)]^
    ^output_name <= ^(i%2);
^[end for]^
    next_edge_time = 0;
end

// rerun this when ctrl changes plus at least once per cycle to reset events
real prev_edge_delay, remaining_fraction, remaining_delay;
always @(ctrl or recalculate) begin
    $display("Top of recalculate at %g", $realtime);
    $display("Next edge time %g", next_edge_time);
    $display($realtime - next_edge_time);

    // calculate new period based on new input
    period_seconds = 500e-12 + 400e-12 * ctrl[1] + 200e-12 * ctrl[0];
    period = (period_seconds * 1e12);
    prev_edge_delay = edge_delay;
    edge_delay = period / ^(N*2);
    if ($realtime < next_edge_time - EPSILON) begin
        $display("    First case - here too early, could be ctrl change");
        // probably a change in ctrl, but could also be an old event left over
        remaining_fraction = (next_edge_time - $realtime) / prev_edge_delay;
        remaining_delay = remaining_fraction * edge_delay;
        next_edge_time = $realtime + remaining_delay;
        $display("    Scheduling recalculate, next_edge_time is %g", next_edge_time);
        -> schedule_recalculate;

    // TODO one big flaw with this design is its reliance on floating point
    // equality in the next line. It should be ok if timescale and timestep
    // match, because then next_edge time should be integer?
    end else if ($abs(next_edge_time - $realtime) < EPSILON) begin
        $display("    Second case");
        
^[for i in range(2*N)]^
^{condition = f'event_id == {i}'}^
^{value = f'{output_names[i%N]} <= {i%2}'}^
        ^[if i != 0]^ else ^[end if]^ ^[if i != 2*N-1]^ if (^condition) ^[end if]^ ^value;
^[end for]^

        event_id = (event_id+1) % ^(N*2);
        $display("    Calculating next_edge_time with delay %g", edge_delay);
        next_edge_time = $realtime + edge_delay;
        $display("    New next_edge_time %g", next_edge_time);
        -> schedule_recalculate;
    end else begin
        // $realtime > next_edge_time
        $display("Oscillator model missed an edge?");
    end
end

always @(schedule_recalculate) #(next_edge_time - $realtime) -> recalculate;

endmodule
